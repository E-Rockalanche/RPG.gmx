<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_globals();

var seed = string_hash(get_string("seed", ""));
random_set_seed(seed);

grid = ds_grid_create(256, 256);
astar = Astar(256, 256);

mountain_grid = -1;
forest_grid = -1;
desert_grid = -1;
grass_grid = -1;

water_level = 0;
mountain_level = 0.05;
desert_level = 0.70;
forest_level = 0.3;
grass_level = 0.25;

frequency = 4;
octaves = 5;
exponent = 10;

min_town_region_size = 16;

surf = -1;

region_index = ds_map_create();
region_list = ds_list_create();
ocean_size = 0;
largest_continent_size = 0;

mx = 0;
my = 0;

show_minimap = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// mouse

if (mouse_check_button(mb_right)) {
    view_xview = device_mouse_raw_x(0)*16;
    view_yview = device_mouse_raw_y(0)*16;
} else if (mouse_check_button_pressed(mb_left)) {
    mx = floor(mouse_x);
    my = floor(mouse_y);
} else if (mouse_check_button(mb_left)) {
    view_xview += mx - floor(mouse_x);
    view_yview += my - floor(mouse_y);
}

if (mouse_wheel_up()) {
    view_wview /= 2;
    view_hview /= 2;
} else if (mouse_wheel_down()) {
    view_wview *= 2;
    view_hview *= 2;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// keyboard

if (keyboard_check_pressed(ord('H'))) {
    show_minimap = !show_minimap;
}

if (keyboard_check_pressed(ord('S'))) {
    screen_save(get_save_filename(".png", "screenshot"));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_colour(c_white);
if (keyboard_check(ord('M'))) {
    draw_set_alpha(1);
    draw_surface_stretched(surf, 0, 0, view_wport, view_hport);
} else if (show_minimap) {
    draw_set_alpha(0.5);
    var minimap_size = 256;
    draw_surface(surf, 0, 0);
    
    var vx = floor(view_xview/16) * minimap_size/256;
    var vy = floor(view_yview/16) * minimap_size/256;
    draw_set_colour(c_yellow);
    var view_size = view_wview/16 * minimap_size/256;
    draw_rectangle(vx, vy, vx+view_size-1, vy+view_size-1, true);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_alpha(1);

if (!surface_exists(surf)) {
    var time = current_time;
    
    surf = surface_create(256, 256);
    surface_set_target(surf);
    for(var i = 0; i &lt; 256; ++i) {
        for(var j = 0; j &lt; 256; ++j) {
            var r = 0;
            var g = 0;
            var b = 0;
            switch(grid[# i, j]) {
                case Tile.WATER:
                    g = 41;
                    b = 123;
                    break;
                case Tile.LAND:
                    g = 90;
                    b = 8;
                    break;
                case Tile.MOUNTAIN:
                    r = 123;
                    g = 90;
                    b = 24;
                    break;
                case Tile.FOREST:
                    g = 57;
                    b = 16;
                    break;
                case Tile.DESERT:
                    r = 214;
                    g = 189;
                    b = 107;
                    break;
                case Tile.GRASS:
                    g = 115;
                    b = 16;
                    break;
            }
            draw_set_colour(make_colour_rgb(r, g, b));
            draw_point(i, j);
        }
    }
    with(obj_town) {
        var i = x div 16;
        var j = y div 16;
        draw_set_colour(c_white);
        draw_point(i, j);
    }
    surface_reset_target();
    
    cout("draw time: ", current_time-time, "ms");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="32">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// generate map

var time = current_time;

tile_layer_delete(0);
tile_layer_delete(-1);

ds_grid_clear(grid, 0);
ds_grid_perlin_noise(grid, 1, frequency, octaves, true, false);
gridNoiseFallOff(grid, exponent);

gridSetLand(grid, water_level);

mountain_grid = ds_grid_create(256, 256);
ds_grid_perlin_noise(mountain_grid, 1, frequency*2, 4, false, false);

desert_grid = ds_grid_create(256, 256);
gridEquatorHill(desert_grid);
ds_grid_multiply_region(desert_grid, 0, 0, 255, 255, 1/frequency);
ds_grid_perlin_noise(desert_grid, 1, frequency, 2, false, false);

forest_grid = ds_grid_create(256, 256);
ds_grid_perlin_noise(forest_grid, 1, frequency*4, 2, false, false);

grass_grid = ds_grid_create(256, 256);
ds_grid_perlin_noise(grass_grid, 1, frequency*4, 2, false, false);

for(var i = 0; i &lt; 256; ++i) {
    for(var j = 0; j &lt; 256; ++j) {
        if (grid[# i, j] == Tile.LAND) {
            if (mountain_grid[# i, j] &gt;= mountain_level) {
                grid[# i, j] = Tile.MOUNTAIN;
                mountain_grid[# i, j] = 1;
            } else if (desert_grid[# i, j] &gt;= desert_level) {
                grid[# i, j] = Tile.DESERT;
            } else if (forest_grid[# i, j] &gt;= forest_level) {
                grid[# i, j] = Tile.FOREST;
            } else if (grass_grid[# i, j] &gt;= grass_level) {
                grid[# i, j] = Tile.GRASS;
            }
        } else {
            mountain_grid[# i, j] = -1;
        }
    }
}

/*
var river_grid = mountain_grid;
seedGrid(river_grid, 30);
gridCellularAutomata(river_grid, 8, default_birth_rules, default_survive_rules);
for(var i = 0; i &lt; 256; ++i) {
    for(var j = 0; j &lt; 256; ++j) {
        if (river_grid[# i, j]) {
            grid[# i, j] = Tile.LAKE;
        }
    }
}
gridFixTiles(grid);

var lake_list = gridFindBlobs(grid, Tile.LAKE);
for(var n = 0; n &lt; ds_list_size(lake_list); n++) {
    var tile_list = lake_list[| n];
    var pos = ds_list_get_random(tile_list);
    ds_list_destroy(tile_list);
    var i = PositionX(pos);
    var j = PositionY(pos);
    
    // generate river
}
ds_list_destroy(lake_list);
*/

gridFixTiles(grid);

var walkable_tiles = array_create(Tile.LENGTH);
walkable_tiles[Tile.LAND] = true;
walkable_tiles[Tile.DESERT] = true;
walkable_tiles[Tile.FOREST] = true;
walkable_tiles[Tile.GRASS] = true;
var region_grid = ds_grid_create(256, 256);
var region_list = ds_list_create();
gridSortRegions(grid, walkable_tiles, region_grid, region_list);

for(var n = 0; n &lt; ds_list_size(region_list); n++) {
    var region = region_list[| n];
    if (region[? "size"] &gt;= min_town_region_size) {
        var tile_list = region[? "tiles"];
        var pos = ds_list_get_random(tile_list);
        instance_create(PositionX(pos)*16, PositionY(pos)*16, obj_town);
    }
}

scr_place_map_tiles();

ds_grid_destroy(mountain_grid);
ds_grid_destroy(desert_grid);
ds_grid_destroy(forest_grid);

cout("total map generation time: ", current_time-time, "ms");

surface_free(surf);
surf = -1;

scr_map_stats();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
